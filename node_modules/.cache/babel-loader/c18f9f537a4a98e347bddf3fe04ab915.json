{"ast":null,"code":"import _slicedToArray from \"/Users/lambda_school_loaner_126/Desktop/CMT-FE/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useRef, useMemo, useEffect, useCallback } from 'react';\nimport { debounce } from 'debounce';\nimport { ResizeObserver as ResizeObserver$1 } from '@juggle/resize-observer';\nconst ResizeObserver = window && window.ResizeObserver || ResizeObserver$1;\n\nfunction useMeasure({\n  debounce: debounce$1,\n  scroll\n} = {\n  debounce: 0,\n  scroll: false\n}) {\n  const _useState = useState({\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0,\n    bottom: 0,\n    right: 0,\n    x: 0,\n    y: 0\n  }),\n        _useState2 = _slicedToArray(_useState, 2),\n        bounds = _useState2[0],\n        set = _useState2[1];\n\n  const lastBounds = useRef(bounds);\n\n  let _useElementState = useElementState({\n    element: null,\n    scrollContainers: null\n  }, element => ({\n    element,\n    scrollContainers: findScrollContainers(element)\n  })),\n      _useElementState2 = _slicedToArray(_useElementState, 2),\n      ref = _useElementState2[0],\n      state = _useElementState2[1];\n\n  const _useMemo = useMemo(() => {\n    const callback = () => {\n      if (!state.current.element) return;\n\n      const _state$current$elemen = state.current.element.getBoundingClientRect(),\n            left = _state$current$elemen.left,\n            top = _state$current$elemen.top,\n            width = _state$current$elemen.width,\n            height = _state$current$elemen.height,\n            bottom = _state$current$elemen.bottom,\n            right = _state$current$elemen.right,\n            x = _state$current$elemen.x,\n            y = _state$current$elemen.y;\n\n      const size = {\n        left,\n        top,\n        width,\n        height,\n        bottom,\n        right,\n        x,\n        y\n      };\n      Object.freeze(size);\n      if (!areBoundsEqual(lastBounds.current, size)) set(lastBounds.current = size);\n    };\n\n    return [debounce$1 ? debounce(callback, typeof debounce$1 === 'number' ? debounce$1 : debounce$1.resize) : callback, debounce$1 ? debounce(callback, typeof debounce$1 === 'number' ? debounce$1 : debounce$1.scroll) : callback];\n  }, [set, debounce$1]),\n        _useMemo2 = _slicedToArray(_useMemo, 2),\n        resizeChange = _useMemo2[0],\n        scrollChange = _useMemo2[1];\n\n  useOnScroll(scroll ? state.current.scrollContainers : null, scrollChange);\n  useOnWindowResize(resizeChange);\n  useEffect(() => {\n    const ro = new ResizeObserver(resizeChange);\n    if (state.current.element) ro.observe(state.current.element);\n    return () => ro.disconnect();\n  }, [state.current.element, resizeChange]);\n  return [ref, bounds];\n} // Lets you reference an element and stores state based off that same element\n\n\nfunction useElementState(initialState, elementToState) {\n  const state = useRef(initialState);\n  const lastElement = useRef(null);\n  const ref = useCallback( // did the reference change?\n  node => node && node !== lastElement.current && (state.current = elementToState(lastElement.current = node)), [elementToState]);\n  return [ref, state];\n} // Adds native scroll listeners to a list of elements\n\n\nfunction useOnScroll(scrollContainers, onScroll) {\n  useEffect(() => {\n    if (!scrollContainers) return;\n    const cb = onScroll;\n    const elements = [window, ...scrollContainers];\n    elements.forEach(element => element.addEventListener('scroll', cb, {\n      capture: true,\n      passive: true\n    }));\n    return () => elements.forEach(element => element.removeEventListener('scroll', cb, true));\n  }, [onScroll, scrollContainers]);\n} // Adds native resize listener to window\n\n\nfunction useOnWindowResize(onWindowResize) {\n  useEffect(() => {\n    const cb = onWindowResize;\n    window.addEventListener('resize', cb);\n    return () => window.removeEventListener('resize', cb);\n  }, [onWindowResize]);\n} // Returns a list of scroll offsets\n\n\nfunction findScrollContainers(element) {\n  const result = [];\n  if (!element || element === document.body) return result;\n\n  const _window$getComputedSt = window.getComputedStyle(element),\n        overflow = _window$getComputedSt.overflow,\n        overflowX = _window$getComputedSt.overflowX,\n        overflowY = _window$getComputedSt.overflowY;\n\n  if ([overflow, overflowX, overflowY].some(prop => prop === 'auto' || prop === 'scroll')) result.push(element);\n  return [...result, ...findScrollContainers(element.parentElement)];\n} // Checks if element boundaries are equal\n\n\nconst keys = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height'];\n\nconst areBoundsEqual = (a, b) => keys.every(key => a[key] === b[key]);\n\nexport default useMeasure;","map":null,"metadata":{},"sourceType":"module"}