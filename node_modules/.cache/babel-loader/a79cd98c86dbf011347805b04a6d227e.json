{"ast":null,"code":"var _jsxFileName = \"/Users/lambda_school_loaner_126/Desktop/CMT-FE/src/Components/ThreeEffects/StaticGlitch/StaticGlitch.js\";\nimport React, { useRef, useEffect } from 'react';\nimport * as THREE from 'three';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { GlitchPass } from 'three/examples/jsm/postprocessing/GlitchPass.js';\nimport { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\nexport default function StaticGlitch(props) {\n  const StaticRef = useRef();\n  useEffect(() => {\n    var camera, scene, renderer, composer;\n    var object, light;\n    var glitchPass;\n    let background = props.background;\n    init();\n    animate();\n\n    function updateOptions() {\n      var wildGlitch = document.getElementById('wildGlitch');\n      glitchPass.goWild = wildGlitch.checked;\n    }\n\n    function init() {\n      renderer = new THREE.WebGLRenderer();\n      renderer.setPixelRatio(window.devicePixelRatio);\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      document.body.appendChild(renderer.domElement); //\n\n      camera = new THREE.PerspectiveCamera(150, window.innerWidth / window.innerHeight, 1, 1000);\n      camera.position.z = 400;\n      scene = new THREE.Scene();\n      scene.fog = new THREE.Fog(0x000000, 1, 1000);\n      object = new THREE.Object3D();\n      scene.add(object); //============Box Geometry=================//\n\n      function generateGeometry(objectType, numObjects) {\n        function applyVertexColors(geometry, color) {\n          var position = geometry.attributes.position;\n          var colors = [];\n\n          for (var i = 0; i < position.count; i++) {\n            colors.push(color.r, color.g, color.b);\n          }\n\n          geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n        }\n\n        var geometries = [];\n        var matrix = new THREE.Matrix4();\n        var position = new THREE.Vector3();\n        var rotation = new THREE.Euler();\n        var quaternion = new THREE.Quaternion();\n        var scale = new THREE.Vector3();\n        var color = new THREE.Color();\n\n        for (var i = 0; i < numObjects; i++) {\n          position.x = Math.random() * 10000 - 5000;\n          position.y = Math.random() * 6000 - 3000;\n          position.z = Math.random() * 8000 - 4000;\n          rotation.x = Math.random() * 2 * Math.PI;\n          rotation.y = Math.random() * 2 * Math.PI;\n          rotation.z = Math.random() * 2 * Math.PI;\n          quaternion.setFromEuler(rotation);\n          scale.x = Math.random() * 200 + 100;\n          var geometry;\n\n          if (objectType === 'cube') {\n            geometry = new THREE.BoxBufferGeometry(1, 1, 1);\n            geometry = geometry.toNonIndexed(); // merging needs consistent buffer geometries\n\n            scale.y = Math.random() * 200 + 100;\n            scale.z = Math.random() * 200 + 100;\n            color.setRGB(0, 0, 0.1 + 0.9 * Math.random());\n          } else if (objectType === 'sphere') {\n            geometry = new THREE.IcosahedronBufferGeometry(1, 1);\n            scale.y = scale.z = scale.x;\n            color.setRGB(0.1 + 0.9 * Math.random(), 0, 0);\n          } // give the geom's vertices a random color, to be displayed\n\n\n          applyVertexColors(geometry, color);\n          matrix.compose(position, quaternion, scale);\n          geometry.applyMatrix(matrix);\n          geometries.push(geometry);\n        }\n\n        return BufferGeometryUtils.mergeBufferGeometries(geometries);\n      } // let loader = new THREE.TextureLoader();\n      // const bgTexture = loader.load(background);\n      // scene.background = bgTexture;\n      //===============Light ====================//\n\n\n      scene.add(new THREE.AmbientLight(0x222222));\n      light = new THREE.DirectionalLight(0xffffff);\n      light.position.set(1, 1, 1);\n      scene.add(light); // postprocessing\n\n      composer = new EffectComposer(renderer);\n      composer.addPass(new RenderPass(scene, camera));\n      glitchPass = new GlitchPass();\n      composer.addPass(glitchPass); //\n\n      window.addEventListener('resize', onWindowResize, false);\n      var wildGlitchOption = document.getElementById('wildGlitch');\n      wildGlitchOption.addEventListener('change', updateOptions);\n      updateOptions();\n    }\n\n    function onWindowResize() {\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      composer.setSize(window.innerWidth, window.innerHeight);\n    }\n\n    function animate() {\n      requestAnimationFrame(animate);\n      composer.render();\n    }\n  }, [StaticRef]);\n  return React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113\n    },\n    __self: this\n  }, React.createElement(\"div\", {\n    ref: StaticRef,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114\n    },\n    __self: this\n  }));\n}","map":{"version":3,"sources":["/Users/lambda_school_loaner_126/Desktop/CMT-FE/src/Components/ThreeEffects/StaticGlitch/StaticGlitch.js"],"names":["React","useRef","useEffect","THREE","EffectComposer","RenderPass","GlitchPass","BufferGeometryUtils","StaticGlitch","props","StaticRef","camera","scene","renderer","composer","object","light","glitchPass","background","init","animate","updateOptions","wildGlitch","document","getElementById","goWild","checked","WebGLRenderer","setPixelRatio","window","devicePixelRatio","setSize","innerWidth","innerHeight","body","appendChild","domElement","PerspectiveCamera","position","z","Scene","fog","Fog","Object3D","add","generateGeometry","objectType","numObjects","applyVertexColors","geometry","color","attributes","colors","i","count","push","r","g","b","setAttribute","Float32BufferAttribute","geometries","matrix","Matrix4","Vector3","rotation","Euler","quaternion","Quaternion","scale","Color","x","Math","random","y","PI","setFromEuler","BoxBufferGeometry","toNonIndexed","setRGB","IcosahedronBufferGeometry","compose","applyMatrix","mergeBufferGeometries","AmbientLight","DirectionalLight","set","addPass","addEventListener","onWindowResize","wildGlitchOption","aspect","updateProjectionMatrix","requestAnimationFrame","render"],"mappings":"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","sourcesContent":["import React,{useRef,useEffect} from 'react'\nimport * as THREE from 'three'\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\nimport {RenderPass} from 'three/examples/jsm/postprocessing/RenderPass.js'\nimport {GlitchPass} from 'three/examples/jsm/postprocessing/GlitchPass.js'\nimport { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils.js';\n\nexport default function StaticGlitch(props) {\n    const StaticRef = useRef()\n    useEffect(() => {\n        var camera, scene, renderer, composer;\n        var object, light;\n        var glitchPass;\n        let background = props.background\n        init();\n        animate();\n        function updateOptions() {\n            var wildGlitch = document.getElementById( 'wildGlitch' );\n            glitchPass.goWild = wildGlitch.checked;\n        }\n        function init() {\n            renderer = new THREE.WebGLRenderer();\n            renderer.setPixelRatio( window.devicePixelRatio );\n            renderer.setSize( window.innerWidth, window.innerHeight );\n            document.body.appendChild( renderer.domElement );\n            //\n            camera = new THREE.PerspectiveCamera( 150, window.innerWidth / window.innerHeight, 1, 1000 );\n            camera.position.z = 400;\n            scene = new THREE.Scene();\n            scene.fog = new THREE.Fog( 0x000000, 1, 1000 );\n            object = new THREE.Object3D();\n            scene.add( object );\n        \n            //============Box Geometry=================//\n        \n            function generateGeometry( objectType, numObjects ) {\n                function applyVertexColors( geometry, color ) {\n                    var position = geometry.attributes.position;\n                    var colors = [];\n                    for ( var i = 0; i < position.count; i ++ ) {\n                        colors.push( color.r, color.g, color.b );\n                    }\n                    geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );\n                }\n                var geometries = [];\n                var matrix = new THREE.Matrix4();\n                var position = new THREE.Vector3();\n                var rotation = new THREE.Euler();\n                var quaternion = new THREE.Quaternion();\n                var scale = new THREE.Vector3();\n                var color = new THREE.Color();\n                for ( var i = 0; i < numObjects; i ++ ) {\n                    position.x = Math.random() * 10000 - 5000;\n                    position.y = Math.random() * 6000 - 3000;\n                    position.z = Math.random() * 8000 - 4000;\n                    rotation.x = Math.random() * 2 * Math.PI;\n                    rotation.y = Math.random() * 2 * Math.PI;\n                    rotation.z = Math.random() * 2 * Math.PI;\n                    quaternion.setFromEuler( rotation );\n                    scale.x = Math.random() * 200 + 100;\n                    var geometry;\n                    if ( objectType === 'cube' ) {\n                        geometry = new THREE.BoxBufferGeometry( 1, 1, 1 );\n                        geometry = geometry.toNonIndexed(); // merging needs consistent buffer geometries\n                        scale.y = Math.random() * 200 + 100;\n                        scale.z = Math.random() * 200 + 100;\n                        color.setRGB( 0, 0, 0.1 + 0.9 * Math.random() );\n                    } else if ( objectType === 'sphere' ) {\n                        geometry = new THREE.IcosahedronBufferGeometry( 1, 1 );\n                        scale.y = scale.z = scale.x;\n                        color.setRGB( 0.1 + 0.9 * Math.random(), 0, 0 );\n                    }\n                    // give the geom's vertices a random color, to be displayed\n                    applyVertexColors( geometry, color );\n                    matrix.compose( position, quaternion, scale );\n                    geometry.applyMatrix( matrix );\n                    geometries.push( geometry );\n                }\n                return BufferGeometryUtils.mergeBufferGeometries( geometries );\n            }\n        \n            // let loader = new THREE.TextureLoader();\n            // const bgTexture = loader.load(background);\n            // scene.background = bgTexture;\n            //===============Light ====================//\n            scene.add( new THREE.AmbientLight( 0x222222 ) );\n            light = new THREE.DirectionalLight( 0xffffff );\n            light.position.set( 1, 1, 1 );\n            scene.add( light );\n            // postprocessing\n            composer = new EffectComposer( renderer );\n            composer.addPass( new RenderPass( scene, camera ) );\n            glitchPass = new GlitchPass();\n            composer.addPass( glitchPass );\n            //\n            window.addEventListener( 'resize', onWindowResize, false );\n            var wildGlitchOption = document.getElementById( 'wildGlitch' );\n            wildGlitchOption.addEventListener( 'change', updateOptions );\n            updateOptions();\n        }\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize( window.innerWidth, window.innerHeight );\n            composer.setSize( window.innerWidth, window.innerHeight );\n        }\n        function animate() {\n            requestAnimationFrame( animate );\n            composer.render();\n        }\n    }, [StaticRef])\n    return (\n        <div>\n            <div ref = {StaticRef}></div>\n        </div>\n    )\n}\n"]},"metadata":{},"sourceType":"module"}